agent/api.py:                                elif channel == control_channel and data in ["STOP", "END_STREAM", "ERROR"]:
agent/api.py:                                elif message and isinstance(message, dict) and message.get("channel") == control_channel:
agent/api.py:                                else:
agent/api.py:                                else:
agent/api.py:                                if channel == response_channel and data == "new":
agent/api.py:                                if inspect.iscoroutinefunction(sandbox.fs.upload_file):
agent/api.py:                                if isinstance(data, bytes): data = data.decode('utf-8')
agent/api.py:                                if message and isinstance(message, dict) and message.get("channel") == response_channel:
agent/api.py:                                if response.get('type') == 'status' and response.get('status') in ['completed', 'failed', 'stopped']:
agent/api.py:                                if safe_filename in file_names_in_dir:
agent/api.py:                            else:
agent/api.py:                            except Exception as verify_error:
agent/api.py:                            for response in new_responses:
agent/api.py:                            if hasattr(sandbox, 'fs') and hasattr(sandbox.fs, 'upload_file'):
agent/api.py:                            if message and isinstance(message, dict) and message.get("type") == "message":
agent/api.py:                            if task in tasks:
agent/api.py:                            try:
agent/api.py:                        else:
agent/api.py:                        except Exception as e:
agent/api.py:                        except Exception as upload_error:
agent/api.py:                        except StopAsyncIteration:
agent/api.py:                        finally:
agent/api.py:                        if new_responses_json:
agent/api.py:                        if terminate_stream: break
agent/api.py:                        if upload_successful:
agent/api.py:                        try:
agent/api.py:                        try:
agent/api.py:                     if status_val == 'failed' or status_val == 'stopped':
agent/api.py:                    elif queue_item["type"] == "control":
agent/api.py:                    elif queue_item["type"] == "error":
agent/api.py:                    except Exception as file_error:
agent/api.py:                    except Exception as ttl_err: logger.warning(f"Failed to refresh TTL for {instance_active_key}: {ttl_err}")
agent/api.py:                    finally:
agent/api.py:                    for task in done:
agent/api.py:                    if data == "STOP":
agent/api.py:                    if isinstance(data, bytes): data = data.decode('utf-8')
agent/api.py:                    if queue_item["type"] == "new_response":
agent/api.py:                    if retry == 2:  # Last retry
agent/api.py:                    if verify_result.data:
agent/api.py:                    try:
agent/api.py:                    try: await redis.expire(instance_active_key, redis.REDIS_KEY_TTL)
agent/api.py:                 if status_val in ['completed', 'failed', 'stopped']:
agent/api.py:                else:
agent/api.py:                else:
agent/api.py:                else:
agent/api.py:                except asyncio.CancelledError:
agent/api.py:                except asyncio.CancelledError:
agent/api.py:                except Exception as e:
agent/api.py:                except Exception as e:
agent/api.py:                except Exception as loop_err:
agent/api.py:                for failed_file in failed_uploads: message_content += f"- {failed_file}\n"
agent/api.py:                for file_path in successful_uploads: message_content += f"[Uploaded File: {file_path}]\n"
agent/api.py:                for p_task in pending: p_task.cancel()
agent/api.py:                for response in initial_responses:
agent/api.py:                for task in tasks: task.cancel()
agent/api.py:                if file.filename:
agent/api.py:                if hasattr(update_result, 'data') and update_result.data:
agent/api.py:                if len(parts) == 3:
agent/api.py:                if message and message.get("type") == "message":
agent/api.py:                if retry < 2:  # Not the last retry yet
agent/api.py:                if total_responses % 50 == 0: # Refresh every 50 responses or so
agent/api.py:                try:
agent/api.py:                try:
agent/api.py:                try:
agent/api.py:                while not terminate_stream:
agent/api.py:            else:
agent/api.py:            else:
agent/api.py:            else:
agent/api.py:            except asyncio.CancelledError: pass
agent/api.py:            except Exception as db_error:
agent/api.py:            except Exception as e:
agent/api.py:            except Exception as e: logger.warning(f"Error during stop_checker cancellation: {e}")
agent/api.py:            for file in files:
agent/api.py:            for key in running_keys:
agent/api.py:            if cleaned_name:
agent/api.py:            if current_status != 'running':
agent/api.py:            if failed_uploads:
agent/api.py:            if hasattr(update_result, 'data') and update_result.data:
agent/api.py:            if initial_responses_json:
agent/api.py:            if len(parts) == 3:
agent/api.py:            if listener_task:
agent/api.py:            if not initial_yield_complete:
agent/api.py:            if pubsub_control: await pubsub_control.close()
agent/api.py:            if pubsub_control: await pubsub_control.unsubscribe(control_channel)
agent/api.py:            if pubsub_response: await pubsub_response.close()
agent/api.py:            if pubsub_response: await pubsub_response.unsubscribe(response_channel)
agent/api.py:            if response.get('type') == 'status':
agent/api.py:            if stop_signal_received:
agent/api.py:            if successful_uploads:
agent/api.py:            try:
agent/api.py:            try:
agent/api.py:            try: await stop_checker
agent/api.py:            while not stop_signal_received:
agent/api.py:            while not terminate_stream:
agent/api.py:        else:
agent/api.py:        else:
agent/api.py:        else:
agent/api.py:        except asyncio.CancelledError:
agent/api.py:        except Exception as e:
agent/api.py:        except Exception as e:
agent/api.py:        except Exception as e:
agent/api.py:        except Exception as e:
agent/api.py:        except Exception as e:
agent/api.py:        except Exception as e:
agent/api.py:        except Exception as fetch_err:
agent/api.py:        except Exception as redis_err:
agent/api.py:        finally:
agent/api.py:        for key in instance_keys:
agent/api.py:        for retry in range(3):
agent/api.py:        if active_runs.data and len(active_runs.data) > 0:
agent/api.py:        if error:
agent/api.py:        if files:
agent/api.py:        if final_status == "running":
agent/api.py:        if generated_name:
agent/api.py:        if instance_id: # Ensure instance_id is set
agent/api.py:        if not pubsub: return
agent/api.py:        if pubsub:
agent/api.py:        if response and response.get('choices') and response['choices'][0].get('message'):
agent/api.py:        if responses:
agent/api.py:        if stop_checker and not stop_checker.done():
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:        try:
agent/api.py:    elif "token='" in str(vnc_link):
agent/api.py:    else:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    except Exception as e:
agent/api.py:    finally:
agent/api.py:    finally:
agent/api.py:    for run in running_agent_runs.data:
agent/api.py:    if _instance_id:
agent/api.py:    if active_run_id:
agent/api.py:    if hasattr(vnc_link, 'token'):
agent/api.py:    if not agent_run.data:
agent/api.py:    if not can_run:
agent/api.py:    if not can_run:
agent/api.py:    if not instance_id:
agent/api.py:    if not instance_id:
agent/api.py:    if not instance_id:
agent/api.py:    if not project.data:
agent/api.py:    if not thread_result.data:
agent/api.py:    if not update_result.data:
agent/api.py:    if not update_success:
agent/api.py:    if project_data.get('sandbox', {}).get('id'):
agent/api.py:    if project_thread_ids:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/api.py:    try:
agent/run.py:                        if '</ask>' in assistant_text or '</complete>' in assistant_text:
agent/run.py:                    else:
agent/run.py:                    if isinstance(assistant_text, str): # Ensure it's a string
agent/run.py:                    if isinstance(content, str):
agent/run.py:                else:
agent/run.py:                except Exception as e:
agent/run.py:                except json.JSONDecodeError:
agent/run.py:                if browser_state:
agent/run.py:                if screenshot_base64:
agent/run.py:                try:
agent/run.py:            except Exception as e:
agent/run.py:            if chunk.get('type') == 'assistant' and 'content' in chunk:
agent/run.py:            if message_type == 'assistant':
agent/run.py:            try:
agent/run.py:        if isinstance(response, dict) and "status" in response and response["status"] == "error":
agent/run.py:        if last_tool_call in ['ask', 'complete']:
agent/run.py:        if latest_browser_state.data and len(latest_browser_state.data) > 0:
agent/run.py:        if latest_message.data and len(latest_message.data) > 0:
agent/run.py:        if not can_run:
agent/run.py:    if config.RAPID_API_KEY:
agent/run.py:    if config.TAVILY_API_KEY:
agent/run.py:    if not account_id:
agent/run.py:    if not project.data or len(project.data) == 0:
agent/run.py:    if not sandbox_info.get('id'):
agent/run.py:    while continue_execution and iteration_count < max_iterations:
agent/tools/computer_use_tool.py:                if not os.path.exists(screenshots_dir):
agent/tools/computer_use_tool.py:                with open(latest_filename, 'wb') as f:
agent/tools/computer_use_tool.py:                with open(timestamped_filename, 'wb') as f:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:
agent/tools/computer_use_tool.py:            else:  # POST
agent/tools/computer_use_tool.py:            if "image" in result:
agent/tools/computer_use_tool.py:            if method.upper() == "GET":
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:            if result.get("success", False):
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        except Exception as e:
agent/tools/computer_use_tool.py:        if self.session and not self.session.closed:
agent/tools/computer_use_tool.py:        if self.session is None or self.session.closed:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:        try:
agent/tools/computer_use_tool.py:if __name__ == "__main__":
agent/tools/data_providers_tool.py:            if len(error_message) > 200:
agent/tools/data_providers_tool.py:            if len(error_message) > 200:
agent/tools/data_providers_tool.py:            if not route:
agent/tools/data_providers_tool.py:            if not service_name:
agent/tools/data_providers_tool.py:            if not service_name:
agent/tools/data_providers_tool.py:            if route == service_name:
agent/tools/data_providers_tool.py:            if route not in data_provider.get_endpoints().keys():
agent/tools/data_providers_tool.py:            if service_name not in self.register_data_providers:
agent/tools/data_providers_tool.py:            if service_name not in self.register_data_providers:
agent/tools/data_providers_tool.py:        except Exception as e:
agent/tools/data_providers_tool.py:        except Exception as e:
agent/tools/data_providers_tool.py:        try:
agent/tools/data_providers_tool.py:        try:
agent/tools/data_providers/ActiveJobsProvider.py:if __name__ == "__main__":
agent/tools/data_providers/AmazonProvider.py:if __name__ == "__main__":
agent/tools/data_providers/LinkedinProvider.py:if __name__ == "__main__":
agent/tools/data_providers/RapidDataProviderBase.py:        elif method == 'POST':
agent/tools/data_providers/RapidDataProviderBase.py:        else:
agent/tools/data_providers/RapidDataProviderBase.py:        if method == 'GET':
agent/tools/data_providers/RapidDataProviderBase.py:        if not endpoint:
agent/tools/data_providers/RapidDataProviderBase.py:        if route.startswith("/"):
agent/tools/data_providers/TwitterProvider.py:if __name__ == "__main__":
agent/tools/data_providers/YahooFinanceProvider.py:if __name__ == "__main__":
agent/tools/data_providers/ZillowProvider.py:if __name__ == "__main__":
agent/tools/message_tool.py:            if attachments and isinstance(attachments, str):
agent/tools/message_tool.py:        except Exception as e:
agent/tools/message_tool.py:        except Exception as e:
agent/tools/message_tool.py:        try:
agent/tools/message_tool.py:        try:
agent/tools/message_tool.py:if __name__ == "__main__":
agent/tools/sb_browser_tool.py:                    if added_message and 'message_id' in added_message:
agent/tools/sb_browser_tool.py:                    if not "content" in result:
agent/tools/sb_browser_tool.py:                    if not "role" in result:
agent/tools/sb_browser_tool.py:                    if result.get("element_count"):
agent/tools/sb_browser_tool.py:                    if result.get("ocr_text"):
agent/tools/sb_browser_tool.py:                    if result.get("pixels_below"):
agent/tools/sb_browser_tool.py:                    if result.get("title"):
agent/tools/sb_browser_tool.py:                    if result.get("url"):
agent/tools/sb_browser_tool.py:                except json.JSONDecodeError as e:
agent/tools/sb_browser_tool.py:                if params:
agent/tools/sb_browser_tool.py:                try:
agent/tools/sb_browser_tool.py:            else:
agent/tools/sb_browser_tool.py:            else:
agent/tools/sb_browser_tool.py:            if method == "GET" and params:
agent/tools/sb_browser_tool.py:            if response.exit_code == 0:
agent/tools/sb_browser_tool.py:        elif all(coord is not None for coord in [coord_source_x, coord_source_y, coord_target_x, coord_target_y]):
agent/tools/sb_browser_tool.py:        else:
agent/tools/sb_browser_tool.py:        else:
agent/tools/sb_browser_tool.py:        else:
agent/tools/sb_browser_tool.py:        except Exception as e:
agent/tools/sb_browser_tool.py:        if amount is not None:
agent/tools/sb_browser_tool.py:        if amount is not None:
agent/tools/sb_browser_tool.py:        if element_source and element_target:
agent/tools/sb_browser_tool.py:        try:
agent/tools/sb_deploy_tool.py:                else:
agent/tools/sb_deploy_tool.py:                if not dir_info.is_dir:
agent/tools/sb_deploy_tool.py:                if not self.cloudflare_api_token:
agent/tools/sb_deploy_tool.py:                if response.exit_code == 0:
agent/tools/sb_deploy_tool.py:            except Exception as e:
agent/tools/sb_deploy_tool.py:            except Exception as e:
agent/tools/sb_deploy_tool.py:            try:
agent/tools/sb_deploy_tool.py:            try:
agent/tools/sb_deploy_tool.py:        except Exception as e:
agent/tools/sb_deploy_tool.py:        try:
agent/tools/sb_deploy_tool.py:if __name__ == "__main__":
agent/tools/sb_expose_tool.py:            if not 1 <= port <= 65535:
agent/tools/sb_expose_tool.py:        except Exception as e:
agent/tools/sb_expose_tool.py:        except ValueError:
agent/tools/sb_expose_tool.py:        try:
agent/tools/sb_files_tool.py:                except Exception as e:
agent/tools/sb_files_tool.py:                except UnicodeDecodeError:
agent/tools/sb_files_tool.py:                if not project.data or len(project.data) == 0:
agent/tools/sb_files_tool.py:                if not sandbox_info.get('id'):
agent/tools/sb_files_tool.py:                if self._should_exclude_file(rel_path) or file_info.is_dir:
agent/tools/sb_files_tool.py:                try:
agent/tools/sb_files_tool.py:            except Exception as e:
agent/tools/sb_files_tool.py:            for file_info in files:
agent/tools/sb_files_tool.py:            if not self._file_exists(full_path):
agent/tools/sb_files_tool.py:            if not self._file_exists(full_path):
agent/tools/sb_files_tool.py:            if not self._file_exists(full_path):
agent/tools/sb_files_tool.py:            if occurrences == 0:
agent/tools/sb_files_tool.py:            if occurrences > 1:
agent/tools/sb_files_tool.py:            if parent_dir:
agent/tools/sb_files_tool.py:            if preview_url:
agent/tools/sb_files_tool.py:            if preview_url:
agent/tools/sb_files_tool.py:            if preview_url:
agent/tools/sb_files_tool.py:            if self._file_exists(full_path):
agent/tools/sb_files_tool.py:            try:
agent/tools/sb_files_tool.py:        except Exception as e:
agent/tools/sb_files_tool.py:        except Exception as e:
agent/tools/sb_files_tool.py:        except Exception as e:
agent/tools/sb_files_tool.py:        except Exception as e:
agent/tools/sb_files_tool.py:        except Exception as e:
agent/tools/sb_files_tool.py:        except Exception:
agent/tools/sb_files_tool.py:        if file_path.lower().endswith('.html') and self._sandbox_url:
agent/tools/sb_files_tool.py:        if self._sandbox is None:
agent/tools/sb_files_tool.py:        try:
agent/tools/sb_files_tool.py:        try:
agent/tools/sb_files_tool.py:        try:
agent/tools/sb_files_tool.py:        try:
agent/tools/sb_files_tool.py:        try:
agent/tools/sb_files_tool.py:        try:
agent/tools/sb_shell_tool.py:                if logs:
agent/tools/sb_shell_tool.py:            else:
agent/tools/sb_shell_tool.py:            except Exception as e:
agent/tools/sb_shell_tool.py:            except Exception as e:
agent/tools/sb_shell_tool.py:            if folder:
agent/tools/sb_shell_tool.py:            if response.exit_code == 0:
agent/tools/sb_shell_tool.py:            try:
agent/tools/sb_shell_tool.py:            try:
agent/tools/sb_shell_tool.py:        except Exception as e:
agent/tools/sb_shell_tool.py:        for session_name in list(self._sessions.keys()):
agent/tools/sb_shell_tool.py:        if session_name in self._sessions:
agent/tools/sb_shell_tool.py:        if session_name not in self._sessions:
agent/tools/sb_shell_tool.py:        try:
agent/tools/web_search_tool.py:                elif "urls" in data and isinstance(data["urls"], dict):
agent/tools/web_search_tool.py:                else:
agent/tools/web_search_tool.py:                except ValueError:
agent/tools/web_search_tool.py:                if "results" in data and isinstance(data["results"], list):
agent/tools/web_search_tool.py:                if isinstance(search_response, dict)
agent/tools/web_search_tool.py:                if item.get("published_date"):
agent/tools/web_search_tool.py:                if not (url.startswith('http://') or url.startswith('https://')):
agent/tools/web_search_tool.py:                if summary:
agent/tools/web_search_tool.py:                try:
agent/tools/web_search_tool.py:            elif isinstance(data, dict):
agent/tools/web_search_tool.py:            elif isinstance(num_results, int):
agent/tools/web_search_tool.py:            elif isinstance(num_results, str):
agent/tools/web_search_tool.py:            else:
agent/tools/web_search_tool.py:            else:
agent/tools/web_search_tool.py:            for item in extracted:
agent/tools/web_search_tool.py:            for result in raw_results:
agent/tools/web_search_tool.py:            if isinstance(data, list):
agent/tools/web_search_tool.py:            if isinstance(url, str):
agent/tools/web_search_tool.py:            if len(error_message) > 200:
agent/tools/web_search_tool.py:            if len(error_message) > 200:
agent/tools/web_search_tool.py:            if not query or not isinstance(query, str):
agent/tools/web_search_tool.py:            if not url:
agent/tools/web_search_tool.py:            if num_results is None:
agent/tools/web_search_tool.py:        except Exception as e:
agent/tools/web_search_tool.py:        except Exception as e:
agent/tools/web_search_tool.py:        if not self.api_key:
agent/tools/web_search_tool.py:        try:
agent/tools/web_search_tool.py:        try:
agent/tools/web_search_tool.py:if __name__ == "__main__":
agentpress/context_manager.py:                    except json.JSONDecodeError:
agentpress/context_manager.py:                    if role == 'assistant' or role == 'user' or role == 'system' or role == 'tool':
agentpress/context_manager.py:                    try:
agentpress/context_manager.py:                except Exception as e:
agentpress/context_manager.py:                if 'role' not in content and 'type' in msg:
agentpress/context_manager.py:                if isinstance(content, str):
agentpress/context_manager.py:                if msg.get('type') == 'summary':
agentpress/context_manager.py:                try:
agentpress/context_manager.py:            else:
agentpress/context_manager.py:            else:
agentpress/context_manager.py:            else:
agentpress/context_manager.py:            else:
agentpress/context_manager.py:            for msg in messages_result.data:
agentpress/context_manager.py:            if force:
agentpress/context_manager.py:            if len(messages) < 3:
agentpress/context_manager.py:            if not messages:
agentpress/context_manager.py:            if response and hasattr(response, 'choices') and response.choices:
agentpress/context_manager.py:            if summary_result.data and len(summary_result.data) > 0:
agentpress/context_manager.py:            if summary:
agentpress/context_manager.py:            if token_count < self.token_threshold and not force:
agentpress/context_manager.py:        except Exception as e:
agentpress/context_manager.py:        except Exception as e:
agentpress/context_manager.py:        except Exception as e:
agentpress/context_manager.py:        except Exception as e:
agentpress/context_manager.py:        if not messages:
agentpress/context_manager.py:        try:
agentpress/context_manager.py:        try:
agentpress/context_manager.py:        try:
agentpress/context_manager.py:        try:
agentpress/response_processor.py:                                         if last_chunk_pos >= 0: content = content[:last_chunk_pos + len(last_chunk)]
agentpress/response_processor.py:                                        if started_msg_obj: yield started_msg_obj
agentpress/response_processor.py:                                     if xml_chunks:
agentpress/response_processor.py:                                    if config.execute_tools and config.execute_on_stream:
agentpress/response_processor.py:                                    if config.max_xml_tool_calls > 0 and xml_tool_call_count >= config.max_xml_tool_calls:
agentpress/response_processor.py:                                    if hasattr(tool_call_chunk.function, 'arguments'): tool_call_data_chunk['function']['arguments'] = tool_call_chunk.function.arguments
agentpress/response_processor.py:                                    if hasattr(tool_call_chunk.function, 'name'): tool_call_data_chunk['function']['name'] = tool_call_chunk.function.name
agentpress/response_processor.py:                                 if parsed_xml_data:
agentpress/response_processor.py:                                except json.JSONDecodeError: pass
agentpress/response_processor.py:                                if hasattr(tool_call_chunk, 'function'):
agentpress/response_processor.py:                                if hasattr(tool_call_chunk, 'id'): tool_call_data_chunk['id'] = tool_call_chunk.id
agentpress/response_processor.py:                                if hasattr(tool_call_chunk, 'index'): tool_call_data_chunk['index'] = tool_call_chunk.index
agentpress/response_processor.py:                                if hasattr(tool_call_chunk, 'type'): tool_call_data_chunk['type'] = tool_call_chunk.type
agentpress/response_processor.py:                                if result:
agentpress/response_processor.py:                                if started_msg_obj: yield started_msg_obj
agentpress/response_processor.py:                                try:
agentpress/response_processor.py:                             else: # Should not happen with asyncio.wait
agentpress/response_processor.py:                             if config.max_xml_tool_calls > 0 and len(parsed_xml_data) > config.max_xml_tool_calls:
agentpress/response_processor.py:                             if error_msg_obj: yield error_msg_obj
agentpress/response_processor.py:                             if execution["task"].done():
agentpress/response_processor.py:                             if hasattr(tool_call, 'function'):
agentpress/response_processor.py:                             if not any(exec['tool_call'] == tool_call for exec in pending_tool_executions):
agentpress/response_processor.py:                            else: # Manual extraction...
agentpress/response_processor.py:                            except json.JSONDecodeError: continue
agentpress/response_processor.py:                            for tool in remaining_tools]
agentpress/response_processor.py:                            for xml_chunk in xml_chunks:
agentpress/response_processor.py:                            if (tool_calls_buffer.get(idx) and
agentpress/response_processor.py:                            if completed_msg_obj: yield completed_msg_obj
agentpress/response_processor.py:                            if has_complete_tool_call and config.execute_tools and config.execute_on_stream:
agentpress/response_processor.py:                            if hasattr(tool_call_chunk, 'model_dump'): tool_call_data_chunk = tool_call_chunk.model_dump()
agentpress/response_processor.py:                            if not hasattr(tool_call_chunk, 'function'): continue
agentpress/response_processor.py:                            if started_msg_obj: yield started_msg_obj
agentpress/response_processor.py:                            try:
agentpress/response_processor.py:                          for tool_call in response_message.tool_calls:
agentpress/response_processor.py:                         except Exception as e:
agentpress/response_processor.py:                         if config.xml_tool_calling:
agentpress/response_processor.py:                         if parsed_result:
agentpress/response_processor.py:                         try:
agentpress/response_processor.py:                        else:
agentpress/response_processor.py:                        else:
agentpress/response_processor.py:                        else:
agentpress/response_processor.py:                        for tool_call_chunk in delta.tool_calls:
agentpress/response_processor.py:                        if completed_msg_obj: yield completed_msg_obj
agentpress/response_processor.py:                        if config.xml_tool_calling and not (config.max_xml_tool_calls > 0 and xml_tool_call_count >= config.max_xml_tool_calls):
agentpress/response_processor.py:                        if content is not None:
agentpress/response_processor.py:                        if content is not None:
agentpress/response_processor.py:                        if content is not None:
agentpress/response_processor.py:                        if error_msg_obj: yield error_msg_obj
agentpress/response_processor.py:                        if execution["task"].done():
agentpress/response_processor.py:                        if last_assistant_message_object: context.assistant_message_id = last_assistant_message_object['message_id']
agentpress/response_processor.py:                        if not (config.max_xml_tool_calls > 0 and xml_tool_call_count >= config.max_xml_tool_calls):
agentpress/response_processor.py:                        if not config.execute_on_stream and tool_idx not in yielded_tool_indices:
agentpress/response_processor.py:                        if not context.assistant_message_id and last_assistant_message_object:
agentpress/response_processor.py:                        if not has_printed_thinking_prefix:
agentpress/response_processor.py:                        if not tag_stack:  # This is our matching end tag
agentpress/response_processor.py:                        if saved_tool_result_object:
agentpress/response_processor.py:                        if tc_buf['id'] and tc_buf['function']['name'] and tc_buf['function']['arguments']:
agentpress/response_processor.py:                        if value is not None:
agentpress/response_processor.py:                       else: logger.warning(f"Could not map result for tool index {current_tool_idx}")
agentpress/response_processor.py:                       if current_tool_idx in all_tool_data_map:
agentpress/response_processor.py:                     for tc in complete_native_tool_calls:
agentpress/response_processor.py:                     if config.native_tool_calling and hasattr(response_message, 'tool_calls') and response_message.tool_calls:
agentpress/response_processor.py:                     if hasattr(response_message, 'content') and response_message.content:
agentpress/response_processor.py:                    elif mapping.node_type == "content":
agentpress/response_processor.py:                    elif mapping.node_type == "element":
agentpress/response_processor.py:                    elif mapping.node_type == "text":
agentpress/response_processor.py:                    else:
agentpress/response_processor.py:                    else:
agentpress/response_processor.py:                    else:
agentpress/response_processor.py:                    else:
agentpress/response_processor.py:                    else:
agentpress/response_processor.py:                    else:
agentpress/response_processor.py:                    except Exception as e:
agentpress/response_processor.py:                    for chunk in xml_chunks_to_process:
agentpress/response_processor.py:                    for idx, tc_buf in tool_calls_buffer.items():
agentpress/response_processor.py:                    for tc in complete_native_tool_calls:
agentpress/response_processor.py:                    for tc, res in results_list:
agentpress/response_processor.py:                    for tool_call in tool_calls]
agentpress/response_processor.py:                    for tool_call, result, tool_idx, context in tool_results_buffer:
agentpress/response_processor.py:                    for tool_idx in sorted(tool_results_map.keys()):
agentpress/response_processor.py:                    if completed_msg_obj: yield completed_msg_obj
agentpress/response_processor.py:                    if config.native_tool_calling and delta and hasattr(delta, 'tool_calls') and delta.tool_calls:
agentpress/response_processor.py:                    if delta and hasattr(delta, 'content') and delta.content:
agentpress/response_processor.py:                    if delta and hasattr(delta, 'reasoning_content') and delta.reasoning_content:
agentpress/response_processor.py:                    if err_msg_obj: yield err_msg_obj
agentpress/response_processor.py:                    if final_cost is None: # Fall back to calculating cost if direct cost not available or zero
agentpress/response_processor.py:                    if final_cost is not None and final_cost > 0:
agentpress/response_processor.py:                    if final_cost is not None and final_cost > 0:
agentpress/response_processor.py:                    if hasattr(llm_response, '_hidden_params') and 'response_cost' in llm_response._hidden_params and llm_response._hidden_params['response_cost'] is not None and llm_response._hidden_params['response_cost'] != 0.0:
agentpress/response_processor.py:                    if isinstance(result.output, dict) or isinstance(result.output, list):
agentpress/response_processor.py:                    if last_chunk_end_pos > 0:
agentpress/response_processor.py:                    if mapping.node_type == "attribute":
agentpress/response_processor.py:                    if nesting_level == 0:
agentpress/response_processor.py:                    if next_end == -1:  # No closing tag found
agentpress/response_processor.py:                    if next_start != -1 and next_start < next_end:
agentpress/response_processor.py:                    if saved_tool_result_object:
agentpress/response_processor.py:                    if started_msg_obj: yield started_msg_obj
agentpress/response_processor.py:                    if tag_pos != -1 and (next_tag_start == -1 or tag_pos < next_tag_start):
agentpress/response_processor.py:                    if tool_idx in yielded_tool_indices:
agentpress/response_processor.py:                    try:
agentpress/response_processor.py:                 if err_msg_obj: yield err_msg_obj
agentpress/response_processor.py:                 if hasattr(llm_response.choices[0], 'finish_reason'):
agentpress/response_processor.py:                 if response_message:
agentpress/response_processor.py:                elif final_tool_calls_to_process and not config.execute_on_stream:
agentpress/response_processor.py:                elif hasattr(result, 'output'):
agentpress/response_processor.py:                else:
agentpress/response_processor.py:                else:
agentpress/response_processor.py:                else:
agentpress/response_processor.py:                else:
agentpress/response_processor.py:                except Exception as e:
agentpress/response_processor.py:                except Exception as e:
agentpress/response_processor.py:                except Exception as e:
agentpress/response_processor.py:                except Exception as e:
agentpress/response_processor.py:                except json.JSONDecodeError:
agentpress/response_processor.py:                for execution in pending_tool_executions:
agentpress/response_processor.py:                for i, (returned_tool_call, result) in enumerate(tool_results):
agentpress/response_processor.py:                for idx, item in enumerate(parsed_xml_data):
agentpress/response_processor.py:                for tag_name in self.tool_registry.xml_tools.keys():
agentpress/response_processor.py:                if config.execute_on_stream and tool_results_buffer:
agentpress/response_processor.py:                if config.max_xml_tool_calls > 0 and xml_tool_call_count >= config.max_xml_tool_calls and xml_chunks_buffer:
agentpress/response_processor.py:                if config.native_tool_calling and complete_native_tool_calls:
agentpress/response_processor.py:                if config.native_tool_calling and complete_native_tool_calls:
agentpress/response_processor.py:                if config.native_tool_calling:
agentpress/response_processor.py:                if config.xml_tool_calling:
agentpress/response_processor.py:                if current_pos >= len(content):  # Reached end without finding closing tag
agentpress/response_processor.py:                if finish_msg_obj: yield finish_msg_obj
agentpress/response_processor.py:                if finish_msg_obj: yield finish_msg_obj
agentpress/response_processor.py:                if finish_msg_obj: yield finish_msg_obj
agentpress/response_processor.py:                if finish_reason == "xml_tool_limit_reached":
agentpress/response_processor.py:                if hasattr(chunk, 'choices') and chunk.choices and hasattr(chunk.choices[0], 'finish_reason') and chunk.choices[0].finish_reason:
agentpress/response_processor.py:                if hasattr(chunk, 'choices') and chunk.choices:
agentpress/response_processor.py:                if isinstance(result, Exception):
agentpress/response_processor.py:                if isinstance(result, str):
agentpress/response_processor.py:                if last_assistant_message_object:
agentpress/response_processor.py:                if match:
agentpress/response_processor.py:                if next_end == -1:
agentpress/response_processor.py:                if next_start != -1 and next_start < next_end:
agentpress/response_processor.py:                if next_tag_start == -1 or not current_tag:
agentpress/response_processor.py:                if result:
agentpress/response_processor.py:                if tool_results_map:
agentpress/response_processor.py:                try:
agentpress/response_processor.py:                try:
agentpress/response_processor.py:                try:
agentpress/response_processor.py:                try:
agentpress/response_processor.py:                try:
agentpress/response_processor.py:                while current_pos < len(content):
agentpress/response_processor.py:             if err_msg_obj: yield err_msg_obj
agentpress/response_processor.py:            else:
agentpress/response_processor.py:            except Exception as e2:
agentpress/response_processor.py:            for i, (tool_call, result) in enumerate(zip(tool_calls, results)):
agentpress/response_processor.py:            for index, tool_call in enumerate(tool_calls):
agentpress/response_processor.py:            for mapping in schema.mappings:
agentpress/response_processor.py:            for pattern in patterns:
agentpress/response_processor.py:            for xml_chunk in xml_chunks:
agentpress/response_processor.py:            if "id" in tool_call:
agentpress/response_processor.py:            if accumulated_content:
agentpress/response_processor.py:            if assist_start_msg_obj: yield assist_start_msg_obj
agentpress/response_processor.py:            if assistant_message_id:
agentpress/response_processor.py:            if assistant_message_object:
agentpress/response_processor.py:            if assistant_message_object: # Only calculate if assistant message was saved
agentpress/response_processor.py:            if config.execute_tools and tool_calls_to_execute:
agentpress/response_processor.py:            if config.execute_tools:
agentpress/response_processor.py:            if end_msg_obj: yield end_msg_obj
agentpress/response_processor.py:            if end_msg_obj: yield end_msg_obj
agentpress/response_processor.py:            if err_msg_obj: yield err_msg_obj # Yield the saved error message
agentpress/response_processor.py:            if finish_reason == "xml_tool_limit_reached":
agentpress/response_processor.py:            if finish_reason and finish_reason != "xml_tool_limit_reached":
agentpress/response_processor.py:            if finish_reason:
agentpress/response_processor.py:            if hasattr(llm_response, 'choices') and llm_response.choices:
agentpress/response_processor.py:            if isinstance(arguments, str):
agentpress/response_processor.py:            if last_assistant_message_object: # Only calculate if assistant message was saved
agentpress/response_processor.py:            if missing:
agentpress/response_processor.py:            if not tag_match:
agentpress/response_processor.py:            if not tool_fn:
agentpress/response_processor.py:            if not tool_info or not tool_info['schema'].xml_schema:
agentpress/response_processor.py:            if parsing_details:
agentpress/response_processor.py:            if pending_tool_executions:
agentpress/response_processor.py:            if start_msg_obj: yield start_msg_obj
agentpress/response_processor.py:            if start_msg_obj: yield start_msg_obj
agentpress/response_processor.py:            if start_pos == -1:
agentpress/response_processor.py:            if tag_end == -1:
agentpress/response_processor.py:            try:
agentpress/response_processor.py:            while nesting_level > 0 and pos < len(xml_chunk):
agentpress/response_processor.py:            while pos < len(content):
agentpress/response_processor.py:        elif execution_strategy == "parallel":
agentpress/response_processor.py:        else:
agentpress/response_processor.py:        else:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        except Exception as e:
agentpress/response_processor.py:        finally:
agentpress/response_processor.py:        finally:
agentpress/response_processor.py:        if "xml_tag_name" in tool_call:
agentpress/response_processor.py:        if "xml_tag_name" in tool_call:
agentpress/response_processor.py:        if context.function_name in ['ask', 'complete']:
agentpress/response_processor.py:        if context.result.success and tool_message_id:
agentpress/response_processor.py:        if execution_strategy == "sequential":
agentpress/response_processor.py:        if not context.result:
agentpress/response_processor.py:        if not tool_calls:
agentpress/response_processor.py:        if not tool_calls:
agentpress/response_processor.py:        if self.max_xml_tool_calls < 0:
agentpress/response_processor.py:        if self.xml_adding_strategy not in ["user_message", "assistant_message", "inline_edit"]:
agentpress/response_processor.py:        if self.xml_tool_calling is False and self.native_tool_calling is False and self.execute_tools:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        try:
agentpress/response_processor.py:        with a specified role (user or assistant).
agentpress/thread_manager.py:                            if 'arguments' in tool_call['function'] and not isinstance(tool_call['function']['arguments'], str):
agentpress/thread_manager.py:                            if native_max_auto_continues > 0:
agentpress/thread_manager.py:                        elif chunk.get('finish_reason') == 'xml_tool_limit_reached':
agentpress/thread_manager.py:                        else:
agentpress/thread_manager.py:                        if chunk.get('finish_reason') == 'tool_calls':
agentpress/thread_manager.py:                        if isinstance(item, dict) and item.get('type') == 'text' and 'text' in item:
agentpress/thread_manager.py:                        if isinstance(tool_call, dict) and 'function' in tool_call:
agentpress/thread_manager.py:                        if summarized:
agentpress/thread_manager.py:                    elif not enable_context_manager: # Added condition for clarity
agentpress/thread_manager.py:                    except Exception as e:
agentpress/thread_manager.py:                    except json.JSONDecodeError:
agentpress/thread_manager.py:                    for item in working_system_prompt['content']: # Modify the copy
agentpress/thread_manager.py:                    for tool_call in message['tool_calls']:
agentpress/thread_manager.py:                    if chunk.get('type') == 'finish':
agentpress/thread_manager.py:                    if msg.get('role') == 'user':
agentpress/thread_manager.py:                    if not appended:
agentpress/thread_manager.py:                    if temp_msg:
agentpress/thread_manager.py:                    if token_count >= token_threshold and enable_context_manager:
agentpress/thread_manager.py:                    try:
agentpress/thread_manager.py:                    try:
agentpress/thread_manager.py:                elif isinstance(system_content, list):
agentpress/thread_manager.py:                else:
agentpress/thread_manager.py:                else:
agentpress/thread_manager.py:                else:
agentpress/thread_manager.py:                else:
agentpress/thread_manager.py:                except Exception as e:
agentpress/thread_manager.py:                except Exception as e:
agentpress/thread_manager.py:                for i, msg in enumerate(messages):
agentpress/thread_manager.py:                for tag_name, example in xml_examples.items():
agentpress/thread_manager.py:                if isinstance(item, str):
agentpress/thread_manager.py:                if isinstance(response_gen, dict) and "status" in response_gen and response_gen["status"] == "error":
agentpress/thread_manager.py:                if isinstance(system_content, str):
agentpress/thread_manager.py:                if message.get('tool_calls'):
agentpress/thread_manager.py:                if not auto_continue:
agentpress/thread_manager.py:                if processor_config.native_tool_calling:
agentpress/thread_manager.py:                if stream:
agentpress/thread_manager.py:                if temp_msg and last_user_index >= 0:
agentpress/thread_manager.py:                try:
agentpress/thread_manager.py:                try:
agentpress/thread_manager.py:            else:
agentpress/thread_manager.py:            except Exception as e:
agentpress/thread_manager.py:            for item in result.data:
agentpress/thread_manager.py:            for message in messages:
agentpress/thread_manager.py:            if auto_continue and auto_continue_count >= native_max_auto_continues:
agentpress/thread_manager.py:            if not result.data:
agentpress/thread_manager.py:            if result.data and len(result.data) > 0 and isinstance(result.data[0], dict) and 'message_id' in result.data[0]:
agentpress/thread_manager.py:            if xml_examples:
agentpress/thread_manager.py:            try:
agentpress/thread_manager.py:            while auto_continue and (native_max_auto_continues == 0 or auto_continue_count < native_max_auto_continues):
agentpress/thread_manager.py:        except Exception as e:
agentpress/thread_manager.py:        except Exception as e:
agentpress/thread_manager.py:        if include_xml_examples and processor_config.xml_tool_calling:
agentpress/thread_manager.py:        if max_xml_tool_calls > 0 and not processor_config.max_xml_tool_calls:
agentpress/thread_manager.py:        if native_max_auto_continues == 0:
agentpress/thread_manager.py:        if processor_config is None:
agentpress/thread_manager.py:        try:
agentpress/thread_manager.py:        try:
agentpress/tool_registry.py:                    if schema.schema_type == SchemaType.OPENAPI:
agentpress/tool_registry.py:                    if schema.schema_type == SchemaType.XML and schema.xml_schema:
agentpress/tool_registry.py:                for schema in schema_list:
agentpress/tool_registry.py:            for tool_info in self.tools.values()
agentpress/tool_registry.py:            if function_names is None or func_name in function_names:
agentpress/tool_registry.py:            if schema.xml_schema and schema.xml_schema.example:
agentpress/tool_registry.py:            if tool_info['schema'].schema_type == SchemaType.OPENAPI
agentpress/tool_registry.py:        for func_name, schema_list in schemas.items():
agentpress/tool_registry.py:        for tag_name, tool_info in self.xml_tools.items():
agentpress/tool_registry.py:        for tool_info in self.xml_tools.values():
agentpress/tool_registry.py:        for tool_name, tool_info in self.tools.items():
agentpress/tool_registry.py:        if not tool:
agentpress/tool_registry.py:        if not tool:
agentpress/tool.py:            for mapping in mappings:
agentpress/tool.py:            if hasattr(method, 'tool_schemas'):
agentpress/tool.py:        else:
agentpress/tool.py:        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
agentpress/tool.py:        if isinstance(data, str):
agentpress/tool.py:        if mappings:
agentpress/tool.py:    if not hasattr(func, 'tool_schemas'):
Binary file agentpress/__pycache__/response_processor.cpython-312.pyc matches
sandbox/api.py:            if not (account_user_result.data and len(account_user_result.data) > 0):
sandbox/api.py:        for file in files:
sandbox/api.py:        if account_id:
sandbox/api.py:        if account_user_result.data and len(account_user_result.data) > 0:
sandbox/api.py:        if isinstance(content, str):
sandbox/api.py:        if not path:
sandbox/api.py:        if not user_id:
sandbox/api.py:        if retrieved_sandbox_id != sandbox_id:
sandbox/api.py:    except Exception as e:
sandbox/api.py:    except Exception as e:
sandbox/api.py:    except Exception as e:
sandbox/api.py:    except Exception as e:
sandbox/api.py:    except Exception as e:
sandbox/api.py:    except Exception as e:
sandbox/api.py:    if account_id:
sandbox/api.py:    if not project_data.get('is_public'):
sandbox/api.py:    if not project_result.data or len(project_result.data) == 0:
sandbox/api.py:    if not project_result.data or len(project_result.data) == 0:
sandbox/api.py:    if not project_result.data or len(project_result.data) == 0:
sandbox/api.py:    if not user_id:
sandbox/api.py:    if project_data.get('is_public'):
sandbox/api.py:    try:
sandbox/api.py:    try:
sandbox/api.py:    try:
sandbox/api.py:    try:
sandbox/api.py:    try:
sandbox/api.py:    try:
sandbox/docker/browser_api.py:                                if text and value in text:
sandbox/docker/browser_api.py:                            if key in include_attributes and value and value != node.tag_name:
sandbox/docker/browser_api.py:                        for key, value in node.attributes.items():
sandbox/docker/browser_api.py:                        if attr_name in node.attributes and node.attributes[attr_name]:
sandbox/docker/browser_api.py:                    elif attributes_str:
sandbox/docker/browser_api.py:                    else:
sandbox/docker/browser_api.py:                    for (const attr of el.attributes) {
sandbox/docker/browser_api.py:                    for attr_name in ['id', 'href', 'name', 'value', 'type']:
sandbox/docker/browser_api.py:                    for el in click_result_2.interactive_elements:
sandbox/docker/browser_api.py:                    if attr_name in element.attributes:
sandbox/docker/browser_api.py:                    if await locator.count() > 0 and await locator.first.is_visible():
sandbox/docker/browser_api.py:                    if delay_ms > 0:
sandbox/docker/browser_api.py:                    if include_attributes:
sandbox/docker/browser_api.py:                    if node.text and node.text.strip():
sandbox/docker/browser_api.py:                    if text:
sandbox/docker/browser_api.py:                elif self.current_page_index >= action.page_id:
sandbox/docker/browser_api.py:                else:
sandbox/docker/browser_api.py:                else:
sandbox/docker/browser_api.py:                else:
sandbox/docker/browser_api.py:                else:
sandbox/docker/browser_api.py:                except Exception as click_error:
sandbox/docker/browser_api.py:                except Exception:
sandbox/docker/browser_api.py:                for attr_name in ['id', 'href', 'src', 'alt', 'placeholder', 'name', 'role', 'title', 'type']:
sandbox/docker/browser_api.py:                for child in node.children:
sandbox/docker/browser_api.py:                for child in node.children:
sandbox/docker/browser_api.py:                for el in click_result.interactive_elements:
sandbox/docker/browser_api.py:                for i in range(1, steps + 1):
sandbox/docker/browser_api.py:                if 'pageCoordinates' in el:
sandbox/docker/browser_api.py:                if 'viewportCoordinates' in el:
sandbox/docker/browser_api.py:                if (targetElementInfo.index > 0 && targetElementInfo.index <= visibleElements.length) {
sandbox/docker/browser_api.py:                if click_result_2.elements and click_result_2.elements.strip():
sandbox/docker/browser_api.py:                if click_result_2.interactive_elements and len(click_result_2.interactive_elements) > 0:
sandbox/docker/browser_api.py:                if el.get('text'):
sandbox/docker/browser_api.py:                if element.attributes.get('id'):
sandbox/docker/browser_api.py:                if element.parent is None:
sandbox/docker/browser_api.py:                if element.tag_name.lower() == 'select':
sandbox/docker/browser_api.py:                if node.highlight_index is not None:
sandbox/docker/browser_api.py:                if not node.has_parent_with_highlight_index() and node.is_visible:
sandbox/docker/browser_api.py:                if self.current_page_index >= len(self.pages):
sandbox/docker/browser_api.py:                try:
sandbox/docker/browser_api.py:                try:
sandbox/docker/browser_api.py:                try:
sandbox/docker/browser_api.py:            elif all(coord is not None for coord in [
sandbox/docker/browser_api.py:            elif element.attributes.get("class"):
sandbox/docker/browser_api.py:            elif isinstance(node, DOMElementNode):
sandbox/docker/browser_api.py:            elif isinstance(node, DOMTextNode):
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            else:
sandbox/docker/browser_api.py:            except Exception as browser_error:
sandbox/docker/browser_api.py:            except Exception as e:
sandbox/docker/browser_api.py:            except Exception as e:
sandbox/docker/browser_api.py:            except Exception as e:
sandbox/docker/browser_api.py:            except Exception as page_error:
sandbox/docker/browser_api.py:            except Exception as wait_error:
sandbox/docker/browser_api.py:            for el in result.interactive_elements:
sandbox/docker/browser_api.py:            for el in result.interactive_elements:
sandbox/docker/browser_api.py:            for element in selector_map.values():
sandbox/docker/browser_api.py:            for idx, el in enumerate(elements):
sandbox/docker/browser_api.py:            for idx, element in dom_state.selector_map.items():
sandbox/docker/browser_api.py:            for locator in locators:
sandbox/docker/browser_api.py:            if 0 <= action.page_id < len(self.pages):
sandbox/docker/browser_api.py:            if 0 <= action.page_id < len(self.pages):
sandbox/docker/browser_api.py:            if action.amount is not None:
sandbox/docker/browser_api.py:            if action.amount is not None:
sandbox/docker/browser_api.py:            if action.element_source and action.element_target:
sandbox/docker/browser_api.py:            if action.index not in selector_map:
sandbox/docker/browser_api.py:            if action.index not in selector_map:
sandbox/docker/browser_api.py:            if await target_element_handle.evaluate("node => node !== null"):
sandbox/docker/browser_api.py:            if click_result.element_count > 0: # Check if there are still elements
sandbox/docker/browser_api.py:            if click_result.elements and click_result.elements.strip():
sandbox/docker/browser_api.py:            if click_result.interactive_elements and len(click_result.interactive_elements) > 0:
sandbox/docker/browser_api.py:            if current.highlight_index is not None:
sandbox/docker/browser_api.py:            if element.attributes.get("id"):
sandbox/docker/browser_api.py:            if element.tag_name.lower() == 'select':
sandbox/docker/browser_api.py:            if index not in selector_map:
sandbox/docker/browser_api.py:            if index not in selector_map:
sandbox/docker/browser_api.py:            if isinstance(node, DOMElementNode) and node != self and node.highlight_index is not None:
sandbox/docker/browser_api.py:            if isinstance(node, DOMElementNode):
sandbox/docker/browser_api.py:            if isinstance(node, DOMTextNode):
sandbox/docker/browser_api.py:            if max_depth != -1 and current_depth > max_depth:
sandbox/docker/browser_api.py:            if result.ocr_text:
sandbox/docker/browser_api.py:            if screenshot:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:            try:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        else:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        except Exception as e:
sandbox/docker/browser_api.py:        for key, value in self.attributes.items():
sandbox/docker/browser_api.py:        if content_result.content:
sandbox/docker/browser_api.py:        if elements is None:
sandbox/docker/browser_api.py:        if extras:
sandbox/docker/browser_api.py:        if not result.success:
sandbox/docker/browser_api.py:        if not result.success:
sandbox/docker/browser_api.py:        if not result.success:
sandbox/docker/browser_api.py:        if not screenshot_base64:
sandbox/docker/browser_api.py:        if not self.pages:
sandbox/docker/browser_api.py:        if result.element_count > 0:
sandbox/docker/browser_api.py:        if result.element_count > 4: # Ensure element 5 exists
sandbox/docker/browser_api.py:        if result.elements and result.elements.strip():
sandbox/docker/browser_api.py:        if result.elements and result.elements.strip():
sandbox/docker/browser_api.py:        if result.interactive_elements and len(result.interactive_elements) > 0:
sandbox/docker/browser_api.py:        if result.interactive_elements and len(result.interactive_elements) > 0:
sandbox/docker/browser_api.py:        if result.ocr_text:
sandbox/docker/browser_api.py:        if result.success:
sandbox/docker/browser_api.py:        if self.browser:
sandbox/docker/browser_api.py:        if self.highlight_index is not None:
sandbox/docker/browser_api.py:        if self.is_interactive:
sandbox/docker/browser_api.py:        if self.is_top_element:
sandbox/docker/browser_api.py:        if tab_result.success:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        try:
sandbox/docker/browser_api.py:        while current is not None:
sandbox/docker/browser_api.py:    elif test_mode_2:
sandbox/docker/browser_api.py:    else:
sandbox/docker/browser_api.py:    except Exception as e:
sandbox/docker/browser_api.py:    except Exception as e:
sandbox/docker/browser_api.py:    finally:
sandbox/docker/browser_api.py:    finally:
sandbox/docker/browser_api.py:    if test_mode_1:
sandbox/docker/browser_api.py:    try:
sandbox/docker/browser_api.py:    try:
sandbox/docker/browser_api.py:if __name__ == '__main__':
sandbox/docker/server.py:        if not os.path.exists(workspace_dir):
sandbox/docker/server.py:if __name__ == '__main__':
sandbox/sandbox.py:                if not project.data or len(project.data) == 0:
sandbox/sandbox.py:                if not sandbox_info.get('id'):
sandbox/sandbox.py:            except Exception as e:
sandbox/sandbox.py:            except Exception as e:
sandbox/sandbox.py:            try:
sandbox/sandbox.py:            try:
sandbox/sandbox.py:        if sandbox.instance.state == WorkspaceState.ARCHIVED or sandbox.instance.state == WorkspaceState.STOPPED:
sandbox/sandbox.py:        if self._sandbox is None:
sandbox/sandbox.py:        if self._sandbox is None:
sandbox/sandbox.py:        if self._sandbox_id is None:
sandbox/sandbox.py:    except Exception as e:
sandbox/sandbox.py:    except Exception as e:
sandbox/sandbox.py:    if project_id:
sandbox/sandbox.py:    try:
sandbox/sandbox.py:    try:
sandbox/sandbox.py:else:
sandbox/sandbox.py:else:
sandbox/sandbox.py:else:
sandbox/sandbox.py:if daytona_config.api_key:
sandbox/sandbox.py:if daytona_config.server_url:
sandbox/sandbox.py:if daytona_config.target:
services/llm.py:                         if "cache_control" not in item:
services/llm.py:                        if "cache_control" not in item:
services/llm.py:                     if isinstance(item, dict) and item.get("type") == "text":
services/llm.py:                    if isinstance(item, dict) and item.get("type") == "text":
services/llm.py:                 for item in content:
services/llm.py:                elif second_last_user_idx == -1:
services/llm.py:                for item in content:
services/llm.py:                if last_assistant_idx == -1:
services/llm.py:                if last_user_idx == -1:
services/llm.py:            elif isinstance(content, list):
services/llm.py:            elif isinstance(content, list):
services/llm.py:            elif role == "assistant":
services/llm.py:            if app_name:
services/llm.py:            if isinstance(content, str):
services/llm.py:            if isinstance(content, str):
services/llm.py:            if last_user_idx != -1 and second_last_user_idx != -1 and last_assistant_idx != -1:
services/llm.py:            if message_idx == -1:
services/llm.py:            if role == "user":
services/llm.py:            if site_url:
services/llm.py:        else:
services/llm.py:        else:
services/llm.py:        except (litellm.exceptions.RateLimitError, OpenAIError, json.JSONDecodeError) as e:
services/llm.py:        except Exception as e:
services/llm.py:        for i in range(len(messages) - 1, -1, -1):
services/llm.py:        if key:
services/llm.py:        if messages and messages[0].get("role") == "system":
services/llm.py:        if model_name.startswith("bedrock/") and "claude-3-7" in model_name:
services/llm.py:        if not isinstance(messages, list):
services/llm.py:        if not model_id and "anthropic.claude-3-7-sonnet" in model_name:
services/llm.py:        if site_url or app_name:
services/llm.py:        try:
services/llm.py:    else:
services/llm.py:    else:
services/llm.py:    except Exception as e:
services/llm.py:    except Exception as e:
services/llm.py:    for attempt in range(MAX_RETRIES):
services/llm.py:    for provider in providers:
services/llm.py:    if "claude" in effective_model_name.lower() or "anthropic" in effective_model_name.lower():
services/llm.py:    if "claude" in model_name.lower() or "anthropic" in model_name.lower():
services/llm.py:    if api_base:
services/llm.py:    if api_key:
services/llm.py:    if aws_access_key and aws_secret_key and aws_region:
services/llm.py:    if config.OPENROUTER_API_KEY and config.OPENROUTER_API_BASE:
services/llm.py:    if is_anthropic and use_thinking:
services/llm.py:    if last_error:
services/llm.py:    if max_tokens is not None:
services/llm.py:    if model_id:
services/llm.py:    if model_name.startswith("bedrock/"):
services/llm.py:    if model_name.startswith("openrouter/"):
services/llm.py:    if test_success:
services/llm.py:    if tools:
services/llm.py:    try:
services/llm.py:    try:    
services/llm.py:if __name__ == "__main__":
services/redis.py:            except Exception as e:
services/redis.py:            try:
services/redis.py:        if not _initialized:
services/redis.py:    if client is None or not _initialized:
services/redis.py:    if client:
services/supabase.py:            if not supabase_url or not supabase_key:
services/supabase.py:        except Exception as e:
services/supabase.py:        if cls._client:
services/supabase.py:        if cls._instance is None:
services/supabase.py:        if not self._client:
services/supabase.py:        if not self._initialized:
services/supabase.py:        if self._initialized:
services/supabase.py:        try:
supabase/functions/billing-functions/index.ts:                if (!validateUrl(body.args.return_url, allowedHosts)) {
supabase/functions/billing-functions/index.ts:                if (!validateUrl(body.args.success_url, allowedHosts) || !validateUrl(body.args.cancel_url, allowedHosts)) {
supabase/functions/billing-functions/index.ts:        if (!body.args?.account_id) {
supabase/functions/billing-functions/index.ts:    if (req.method === "OPTIONS") {
supabase/migrations/20240414161707_basejump-setup.sql:    for select
supabase/migrations/20240414161707_basejump-setup.sql:    if TG_OP = 'INSERT' then
supabase/migrations/20240414161707_basejump-setup.sql:    if TG_OP = 'INSERT' then
supabase/migrations/20240414161947_basejump-accounts.sql:        if is_account_primary_owner = false then
supabase/migrations/20240414161947_basejump-accounts.sql:        if NEW.id <> OLD.id
supabase/migrations/20240414161947_basejump-accounts.sql:    for delete
supabase/migrations/20240414161947_basejump-accounts.sql:    for each row
supabase/migrations/20240414161947_basejump-accounts.sql:    for insert
supabase/migrations/20240414161947_basejump-accounts.sql:    for select
supabase/migrations/20240414161947_basejump-accounts.sql:    for select
supabase/migrations/20240414161947_basejump-accounts.sql:    for select
supabase/migrations/20240414161947_basejump-accounts.sql:    for select
supabase/migrations/20240414161947_basejump-accounts.sql:    for update
supabase/migrations/20240414161947_basejump-accounts.sql:    if (select public.current_user_account_role(get_account_members.account_id) ->> 'account_role' <> 'owner') then
supabase/migrations/20240414161947_basejump-accounts.sql:    if basejump.has_role_on_account(remove_account_member.account_id, 'owner') <> true then
supabase/migrations/20240414161947_basejump-accounts.sql:    if changing_primary_owner = true and is_account_primary_owner = false then
supabase/migrations/20240414161947_basejump-accounts.sql:    if current_user IN ('anon', 'authenticated') and
supabase/migrations/20240414161947_basejump-accounts.sql:    if current_user IN ('anon', 'authenticated') and
supabase/migrations/20240414161947_basejump-accounts.sql:    if make_primary_owner = true then
supabase/migrations/20240414161947_basejump-accounts.sql:    if new.email IS NOT NULL then
supabase/migrations/20240414161947_basejump-accounts.sql:    if new.primary_owner_user_id = auth.uid() then
supabase/migrations/20240414161947_basejump-accounts.sql:    if NEW.slug is not null then
supabase/migrations/20240414161947_basejump-accounts.sql:    if not is_account_owner then
supabase/migrations/20240414161947_basejump-accounts.sql:    if response ->> 'account_role' IS NULL then
supabase/migrations/20240414161947_basejump-accounts.sql:    with check (
supabase/migrations/20240414162100_basejump-invitations.sql:    for delete
supabase/migrations/20240414162100_basejump-invitations.sql:    for insert
supabase/migrations/20240414162100_basejump-invitations.sql:    for select
supabase/migrations/20240414162100_basejump-invitations.sql:    if (select public.current_user_account_role(get_account_invitations.account_id) ->> 'account_role' <> 'owner') then
supabase/migrations/20240414162100_basejump-invitations.sql:    if basejump.has_role_on_account(
supabase/migrations/20240414162100_basejump-invitations.sql:    if lookup_account_id is not null then
supabase/migrations/20240414162100_basejump-invitations.sql:    if lookup_account_id IS NULL then
supabase/migrations/20240414162100_basejump-invitations.sql:    with check (
supabase/migrations/20240414162131_basejump-billing.sql:    if customer is not null then
supabase/migrations/20240414162131_basejump-billing.sql:    if subscription is not null then
tests/test_direct_tool_execution.py:    except AssertionError as e:
tests/test_direct_tool_execution.py:    except Exception as e:
tests/test_direct_tool_execution.py:    except KeyboardInterrupt:
tests/test_direct_tool_execution.py:    try:
tests/test_direct_tool_execution.py:if __name__ == "__main__":
tests/test_llm_native_tool_freeze.py:                        else:
tests/test_llm_native_tool_freeze.py:                        if accumulated_tool_input:
tests/test_llm_native_tool_freeze.py:                    except json.JSONDecodeError:
tests/test_llm_native_tool_freeze.py:                    try:
tests/test_llm_native_tool_freeze.py:                else:
tests/test_llm_native_tool_freeze.py:                if 'file_contents' in input_obj:
tests/test_llm_native_tool_freeze.py:                if 'file_path' in input_obj:
tests/test_llm_native_tool_freeze.py:                if hasattr(event, "stop_reason"):
tests/test_llm_native_tool_freeze.py:                if hasattr(event.delta, "input") and event.delta.input:
tests/test_llm_native_tool_freeze.py:                if hasattr(event.delta, "stop_reason") and event.delta.stop_reason:
tests/test_llm_native_tool_freeze.py:                if hasattr(event.delta, "text") and event.delta.text:
tests/test_llm_native_tool_freeze.py:                if hasattr(event.tool_use, "input") and event.tool_use.input:
tests/test_llm_native_tool_freeze.py:            elif event.type == "content_block_delta":
tests/test_llm_native_tool_freeze.py:            elif event.type == "content_block_start":
tests/test_llm_native_tool_freeze.py:            elif event.type == "message_delta":
tests/test_llm_native_tool_freeze.py:            elif event.type == "message_stop":
tests/test_llm_native_tool_freeze.py:            elif event.type == "tool_use_delta":
tests/test_llm_native_tool_freeze.py:            elif event.type == "tool_use":
tests/test_llm_native_tool_freeze.py:            if accumulated_tool_input:
tests/test_llm_native_tool_freeze.py:            if event.type == "message_start":
tests/test_llm_native_tool_freeze.py:        except json.JSONDecodeError as e:
tests/test_llm_native_tool_freeze.py:        if accumulated_content:
tests/test_llm_native_tool_freeze.py:        if current_tool_name:
tests/test_llm_native_tool_freeze.py:        if not api_key:
tests/test_llm_native_tool_freeze.py:        try:
tests/test_llm_native_tool_freeze.py:    except Exception as e:
tests/test_llm_native_tool_freeze.py:    try:
tests/test_llm_native_tool_freeze.py:if __name__ == "__main__":
tests/test_llm_native_tool_freeze.py:with tool calls containing large JSON payloads.
tests/test_simple_tools.py:                        if hasattr(tool_call.function, 'arguments') and tool_call.function.arguments:
tests/test_simple_tools.py:                        if hasattr(tool_call.function, 'name') and tool_call.function.name:
tests/test_simple_tools.py:                    if hasattr(tool_call, 'function'):
tests/test_simple_tools.py:                    if hasattr(tool_call, 'id') and tool_call.id:
tests/test_simple_tools.py:                    if tool_call.function.name == "create_file":
tests/test_simple_tools.py:                    while len(tool_calls) <= tool_call_index:
tests/test_simple_tools.py:                except Exception as e:
tests/test_simple_tools.py:                except Exception as e:
tests/test_simple_tools.py:                for tool_call in delta.tool_calls:
tests/test_simple_tools.py:                if hasattr(last_chunk, 'choices') and last_chunk.choices:
tests/test_simple_tools.py:                try:
tests/test_simple_tools.py:                try:
tests/test_simple_tools.py:            except Exception as log_ex:
tests/test_simple_tools.py:            for i, tool_call in enumerate(assistant_message.tool_calls):
tests/test_simple_tools.py:            for i, tool_call in enumerate(tool_calls):
tests/test_simple_tools.py:            if hasattr(delta, 'content') and delta.content is not None:
tests/test_simple_tools.py:            if hasattr(delta, 'tool_calls') and delta.tool_calls:
tests/test_simple_tools.py:            if not hasattr(chunk, 'choices') or not chunk.choices:
tests/test_simple_tools.py:            try:
tests/test_simple_tools.py:        else:
tests/test_simple_tools.py:        else:
tests/test_simple_tools.py:        else:
tests/test_simple_tools.py:        if accumulated_content:
tests/test_simple_tools.py:        if hasattr(assistant_message, 'tool_calls') and assistant_message.tool_calls:
tests/test_simple_tools.py:        if last_chunk:
tests/test_simple_tools.py:        if tool_calls:
tests/test_simple_tools.py:    except Exception as e:
tests/test_simple_tools.py:    except Exception as e:
tests/test_simple_tools.py:    try:
tests/test_simple_tools.py:    try:
tests/test_simple_tools.py:if __name__ == "__main__":
tests/test_tool_execution_strategies.py:                if tool_name == 'wait':
tests/test_tool_execution_strategies.py:            for result in test_data['tool_results']
tests/test_tool_execution_strategies.py:            for test_data in test_results.values() 
tests/test_tool_execution_strategies.py:            if chunk.get('type') == 'tool_result':
tests/test_tool_execution_strategies.py:        for result in test_data['tool_results']
tests/test_tool_execution_strategies.py:        for test_data in test_results.values() 
tests/test_tool_execution_strategies.py:    except AssertionError as e:
tests/test_tool_execution_strategies.py:    except Exception as e:
tests/test_tool_execution_strategies.py:    except KeyboardInterrupt:
tests/test_tool_execution_strategies.py:    for test in test_cases:
tests/test_tool_execution_strategies.py:    if all_have_status:
tests/test_tool_execution_strategies.py:    try:
tests/test_tool_execution_strategies.py:if __name__ == "__main__":
tests/test_xml_streaming_execution.py:                    if tool_name == 'wait':
tests/test_xml_streaming_execution.py:                    if tool_name == 'wait':
tests/test_xml_streaming_execution.py:                if chunk.get('type') == 'tool_result':
tests/test_xml_streaming_execution.py:                if chunk.get('type') == 'tool_result':
tests/test_xml_streaming_execution.py:            for result in test_data['tool_results']
tests/test_xml_streaming_execution.py:            for test_data in test_results.values() 
tests/test_xml_streaming_execution.py:        else:
tests/test_xml_streaming_execution.py:        for i in range(0, len(self.content), self.chunk_size):
tests/test_xml_streaming_execution.py:        for result in test_data['tool_results']
tests/test_xml_streaming_execution.py:        for test_data in test_results.values() 
tests/test_xml_streaming_execution.py:        if test['execute_on_stream']:
tests/test_xml_streaming_execution.py:    except AssertionError as e:
tests/test_xml_streaming_execution.py:    except Exception as e:
tests/test_xml_streaming_execution.py:    except KeyboardInterrupt:
tests/test_xml_streaming_execution.py:    for test in test_cases:
tests/test_xml_streaming_execution.py:    if all_have_status:
tests/test_xml_streaming_execution.py:    try:
tests/test_xml_streaming_execution.py:if __name__ == "__main__":
utils/auth_utils.py:            if project_result.data[0].get('is_public'):
utils/auth_utils.py:            if user_id:
utils/auth_utils.py:            if user_id:
utils/auth_utils.py:        except Exception:
utils/auth_utils.py:        except Exception:
utils/auth_utils.py:        if account_user_result.data and len(account_user_result.data) > 0:
utils/auth_utils.py:        if not user_id:
utils/auth_utils.py:        if project_result.data and len(project_result.data) > 0:
utils/auth_utils.py:        try:
utils/auth_utils.py:        try:
utils/auth_utils.py:    except PyJWTError:
utils/auth_utils.py:    except PyJWTError:
utils/auth_utils.py:    if account_id:
utils/auth_utils.py:    if auth_header and auth_header.startswith('Bearer '):
utils/auth_utils.py:    if not auth_header or not auth_header.startswith('Bearer '):
utils/auth_utils.py:    if not auth_header or not auth_header.startswith('Bearer '):
utils/auth_utils.py:    if not thread_result.data or len(thread_result.data) == 0:
utils/auth_utils.py:    if project_id:
utils/auth_utils.py:    if token:
utils/auth_utils.py:    try:
utils/auth_utils.py:    try:
utils/billing.py:        else:
utils/billing.py:        if run['completed_at']:
utils/billing.py:    for run in runs_result.data:
utils/billing.py:    if config.ENV_MODE == EnvMode.LOCAL:
utils/billing.py:    if current_usage >= tier_info['minutes']:
utils/billing.py:    if not runs_result.data:
utils/billing.py:    if not subscription:
utils/billing.py:    if not threads_result.data:
utils/billing.py:    if not tier_info:
utils/billing.py:    if result.data and len(result.data) > 0:
utils/billing.py:    if result.data and len(result.data) > 0:
utils/config.py:                    except ValueError:
utils/config.py:                    try:
utils/config.py:                elif expected_type == EnvMode:
utils/config.py:                elif expected_type == int:
utils/config.py:                else:
utils/config.py:                if expected_type == bool:
utils/config.py:            for key in get_type_hints(self.__class__).keys()
utils/config.py:            if env_val is not None:
utils/config.py:            if not getattr(self, key):
utils/config.py:            if not key.startswith('_')
utils/config.py:        except ValueError:
utils/config.py:        for key in required_keys:
utils/config.py:        for key, expected_type in get_type_hints(self.__class__).items():
utils/config.py:        if self.ENV_MODE != EnvMode.LOCAL:
utils/config.py:        if self.ENV_MODE == EnvMode.PRODUCTION:
utils/config.py:        try:
utils/files_utils.py:    if any(excluded in dir_path for excluded in EXCLUDED_DIRS):
utils/files_utils.py:    if ext.lower() in EXCLUDED_EXT:
utils/files_utils.py:    if filename in EXCLUDED_FILES:
utils/files_utils.py:    if path.startswith('workspace/'):
utils/files_utils.py:    if path.startswith(workspace_path.lstrip('/')):
utils/logger.py:        else:
utils/logger.py:        if config.ENV_MODE == EnvMode.PRODUCTION:
utils/logger.py:        if hasattr(record, 'extra'):
utils/logger.py:        if not os.path.exists(log_dir):
utils/logger.py:        if record.exc_info:
utils/logger.py:    except Exception as e:
utils/logger.py:    except Exception as e:
utils/logger.py:    except Exception as e:
utils/logger.py:    try:
utils/logger.py:    try:
utils/logger.py:    try:
utils/scripts/get_all_xml_tags.py:    for tag_name in xml_examples.keys():
utils/scripts/get_all_xml_tags.py:    if os.getenv("RAPID_API_KEY"):
utils/scripts/get_all_xml_tags.py:    if os.getenv("TAVILY_API_KEY"):
utils/scripts/get_all_xml_tags.py:if __name__ == "__main__":
utils/scripts/get_all_xml_tags.py:if backend_dir not in sys.path:
